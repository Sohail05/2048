<!doctype html>
<html class="no-js" lang="">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>WebGL 2048</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/main.css">
    <script src="js/vendor/modernizr-2.8.3.min.js"></script>

    <script src="js/three.min.js"></script>
    <script src="js/threex.dynamictexture.js"></script>
    <script src="js/vendor/jquery-1.11.2.min.js"></script>

</head>

<body>

    <section id="info">

        <h2>WebGL 2048</h2>

        <p>Controls:
            <br>&#8592; &#151; LEFT ARROW
            <br>&#8594; &#151; RIGHT ARROW
            <br>&#8593; &#151; UP ARROW
            <br>&#8595; &#151; DOWN ARROW
            <br>[ENTER] &#151; RESET
        </p>


    </section>

    <script>
        "use strict";

         //By Sohail Ajmal twitter@Sohail05

        var scene, camera, renderer;
        var geometry, material, mesh;
        var wireGeometry, wireMaterial;
        var grid;
        var center;
        var initiater = 0;
        var score = 0;
        var topScore = 0;
        var scoreBox;
        var topScoreBox;
        var scoreTexture;
        var topScoreTexture;
        var scoreMaterial;
        var topScoreMaterial
        var debug = true;

         //2 4 8 16 32 64 128 256 1024 2048
        var material2048;

        document.onkeydown = inputKey;
        init();
        animate();

        function init() {
            "use strict";

            score = 0;

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 5;
            camera.position.x = 1.5;
            camera.position.y = 1.5;
            center = new THREE.Vector2(1.5, 1.5);

            geometry = new THREE.BoxGeometry(0.9, 0.9, 0.0);
            var col = new THREE.Color(Math.random(), Math.random(), Math.random())
            material = new THREE.MeshBasicMaterial({
                color: col
            });

            material2048 = new Array(12);

            var dynamicTexture = [];
            for (var i = 0; i < 13; i++) {

                dynamicTexture[i] = new THREEx.DynamicTexture(128, 128);
                dynamicTexture[i].clear('white');

                if ((Math.pow(2, i) > 0) && (Math.pow(2, i) < 10)) {
                    dynamicTexture[i].context.font = "120px monospace";
                    dynamicTexture[i].drawText(Math.pow(2, i), 30, 100, 'black');
                } else if ((Math.pow(2, i) > 10) && (Math.pow(2, i) < 100)) {
                    dynamicTexture[i].context.font = "100px monospace";
                    dynamicTexture[i].drawText(Math.pow(2, i), 8, 96, 'black');
                } else if ((Math.pow(2, i) > 100) && (Math.pow(2, i) < 1000)) {
                    dynamicTexture[i].context.font = "70px monospace";
                    dynamicTexture[i].drawText(Math.pow(2, i), 8, 86, 'black');
                } else if (Math.pow(2, i) > 1000) {
                    dynamicTexture[i].context.font = "70px monospace";
                    dynamicTexture[i].drawText(Math.pow(2, i), 8, 86, 'black');
                } else {
                    dynamicTexture[i].context.font = "50px monospace";
                    dynamicTexture[i].drawText(Math.pow(2, i), 8, 80, 'black');
                }

                dynamicTexture[i].texture.needsUpdate = true;
            }

            material2048[0] = new THREE.MeshBasicMaterial({
                color: 0x66FF66,
                map: dynamicTexture[1].texture
            });
            material2048[1] = new THREE.MeshBasicMaterial({
                color: 0x00CC00,
                map: dynamicTexture[2].texture
            });
            material2048[2] = new THREE.MeshBasicMaterial({
                color: 0x00FFCC,
                map: dynamicTexture[3].texture
            });
            material2048[3] = new THREE.MeshBasicMaterial({
                color: 0x00CCFF,
                map: dynamicTexture[4].texture
            });
            material2048[4] = new THREE.MeshBasicMaterial({
                color: 0x0099FF,
                map: dynamicTexture[5].texture
            });
            material2048[5] = new THREE.MeshBasicMaterial({
                color: 0x6666FF,
                map: dynamicTexture[6].texture
            });
            material2048[6] = new THREE.MeshBasicMaterial({
                color: 0xCC33FF,
                map: dynamicTexture[7].texture
            });
            material2048[7] = new THREE.MeshBasicMaterial({
                color: 0xCC0099,
                map: dynamicTexture[8].texture
            });
            material2048[8] = new THREE.MeshBasicMaterial({
                color: 0xFFFF66,
                map: dynamicTexture[9].texture
            });
            material2048[9] = new THREE.MeshBasicMaterial({
                color: 0xFF9966,
                map: dynamicTexture[10].texture
            });
            material2048[10] = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                map: dynamicTexture[11].texture
            });
            material2048[11] = new THREE.MeshBasicMaterial({
                color: 0x800000,
                map: dynamicTexture[12].texture
            });


            wireGeometry = new THREE.BoxGeometry(0.9, 0.9, 0);
            wireMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true
            });

            mesh = new THREE.Mesh(geometry, material);

            grid = new Array(4);
            for (var j = 0; j < 4; j++) {
                grid[j] = new Array(4);
                for (var i = 0; i < 4; i++) {

                    grid[j][i] = new THREE.Mesh(wireGeometry, wireMaterial);
                    grid[j][i].name = "empty";
                    if (debug == true) {
                        scene.add(grid[j][i]);
                    }
                }
            }

            //Score Boxes!
            //Make Textures
            scoreTexture = new THREEx.DynamicTexture(128, 64);
            topScoreTexture = new THREEx.DynamicTexture(128, 64);
            //Make Material
            scoreMaterial = new THREE.MeshBasicMaterial({
                map: scoreTexture.texture
            });
            topScoreMaterial = new THREE.MeshBasicMaterial({
                map: topScoreTexture.texture
            });

            var scoreGeometry = new THREE.BoxGeometry(1.9, 1, 0.0);
            //Make Mesh
            scoreBox = new THREE.Mesh(scoreGeometry, scoreMaterial);
            topScoreBox = new THREE.Mesh(scoreGeometry, topScoreMaterial);

            //Set Position
            scoreBox.position.add(new THREE.Vector3(0.5, 4.5, 0));
            topScoreBox.position.add(new THREE.Vector3(2.5, 4.5, 0));

            //Add to Scene
            scene.add(scoreBox);
            scene.add(topScoreBox);

            if (initiater == 0) {
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                initiater = 1;
            }
            renderer.setClearColor(col, 1);

            AddRandom();
            UpdateScore();

        }

        function animate() {
            "use strict";
            requestAnimationFrame(animate);

            for (var j = 0; j < 4; j++) {
                for (var i = 0; i < 4; i++) {

                    if (grid[j][i] != null) {

                        //array[j][i].position.x = lerp(array[j][i].position.x, i, 0.1);
                        //array[j][i].position.y = lerp(array[j][i].position.y, j, 0.1);
                        grid[j][i].position.lerp(new THREE.Vector3(i, j, 0), 0.1);
                    }
                }
            }


            renderer.render(scene, camera);

        }

        function AddRandom() {
            "use strict";
            var location = [];

            for (var j = 0; j < 4; j++) {
                for (var i = 0; i < 4; i++) {

                    if (grid[j][i].name == "empty") {

                        location.push(new THREE.Vector2(i, j));
                    }
                }
            }


            if (location.length > 0) {

                var random = location[Math.floor(Math.random() * location.length)];

                scene.remove(grid[random.y][random.x]);
                grid[random.y][random.x] = new THREE.Mesh(geometry, material2048[0]);
                grid[random.y][random.x].name = "2";
                grid[random.y][random.x].position.x = center.x;
                grid[random.y][random.x].position.y = center.y;
                scene.add(grid[random.y][random.x]);
                return 0;
            }

            return 1;

        }




        function inputKey(e) {
            "use strict";
            e = e || window.event;

            if (e.keyCode == '37') {
                //left arrow
                HorizontalMerge();
                MoveLeft();
                AddRandom();

            } else if (e.keyCode == '38') {
                //up arrow
                VerticalMerge();
                MoveUp()
                AddRandom();
            } else if (e.keyCode == '39') {
                //right arrow
                HorizontalMerge();
                MoveRight();
                AddRandom();
            } else if (e.keyCode == '40') {
                //down arrow
                VerticalMerge();
                MoveDown()
                AddRandom();
            } else if (e.keyCode == '13 ') {
                //down arrow
                init();
            }
            UpdateScore();


        }

         //This is to give the smooth movement effect 
        function lerp(v0, v1, t) {
            "use strict";
            return (1 - t) * v0 + t * v1;
        }



        function MoveLeft() {
            "use strict";

            for (var j = 0; j < 4; j++) {

                for (var i = 1; i < 4; i++) {

                    if (grid[j][i].name != "empty") {

                        for (var c = 0; c < i; c++) {

                            if (grid[j][c].name == "empty") {
                                Swap([j, i], [j, c]);

                            }
                        }
                    }
                }
            }
        }


        function MoveRight() {
            "use strict";

            for (var j = 3; j >= 0; j--) {

                for (var i = 2; i >= 0; i--) {

                    if (grid[j][i].name != "empty") {

                        for (var c = 3; c > i; c--) {

                            if (grid[j][c].name == "empty") {
                                Swap([j, i], [j, c]);

                            }
                        }
                    }
                }
            }
        }

        function MoveDown() {
            "use strict";

            for (var i = 0; i < 4; i++) {

                for (var j = 1; j < 4; j++) {

                    if (grid[j][i].name != "empty") {

                        for (var c = 0; c < j; c++) {

                            if (grid[c][i].name == "empty") {
                                Swap([j, i], [c, i]);

                            }
                        }
                    }
                }
            }
        }

        function MoveUp() {
            "use strict";

            for (var j = 3; j >= 0; j--) {

                for (var i = 3; i >= 0; i--) {

                    if (grid[j][i].name != "empty") {

                        for (var c = 3; c > j; c--) {

                            if (grid[c][i].name == "empty") {
                                Swap([j, i], [c, i]);

                            }
                        }
                    }
                }
            }
        }

        function HorizontalMerge() {
            "use strict";

            //this shouldn't go over 2 because we only get 2 merge per line
            var mergeCount = 0;

            for (var j = 0; j < 4; j++) {

                for (var i = 0; i < 3; i++) {


                    if (grid[j][i].name != "empty") {

                        for (var z = i + 1; z < 4; z++) {
                            if (grid[j][z].name != "empty") {

                                if (grid[j][i].name == grid[j][z].name) {
                                    mergeBlock([j, i], [j, z]);
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
         //end of HorizontalMerge

        function VerticalMerge() {
            "use strict";

            //this shouldn't go over 2 because we only get 2 merge per line
            var mergeCount = 0;

            for (var i = 0; i < 4; i++) {

                for (var j = 0; j < 3; j++) {

                    if (grid[j][i].name != "empty") {

                        for (var z = j + 1; z < 4; z++) {
                            if (grid[z][i].name != "empty") {

                                if (grid[j][i].name == grid[z][i].name) {
                                    mergeBlock([j, i], [z, i]);
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
         //end of VerticalMerge


        function mergeBlock(a, b) {


            var positionA = grid[a[0]][a[1]].position;
            var positionB = grid[b[0]][b[1]].position;
            scene.remove(grid[a[0]][a[1]]);
            scene.remove(grid[b[0]][b[1]]);

            if (grid[a[0]][a[1]].name == "2") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[1]);
                grid[a[0]][a[1]].name = "4";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "4") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[2]);
                grid[a[0]][a[1]].name = "8";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "8") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[3]);
                grid[a[0]][a[1]].name = "16";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "16") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[4]);
                grid[a[0]][a[1]].name = "32";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "32") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[5]);
                grid[a[0]][a[1]].name = "64";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "64") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[6]);
                grid[a[0]][a[1]].name = "128";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "128") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[7]);
                grid[a[0]][a[1]].name = "256";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "256") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[8]);
                grid[a[0]][a[1]].name = "512";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "512") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[9]);
                grid[a[0]][a[1]].name = "1024";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";

            } else if (grid[a[0]][a[1]].name == "2048") {

                grid[a[0]][a[1]] = new THREE.Mesh(geometry, material2048[10]);
                grid[a[0]][a[1]].name = "1024";

                grid[b[0]][b[1]] = new THREE.Mesh(wireGeometry, wireMaterial);
                grid[b[0]][b[1]].name = "empty";
                //player win

            }




            grid[a[0]][a[1]].position.add(positionA);
            grid[b[0]][b[1]].position.add(positionB);
            scene.add(grid[a[0]][a[1]]);
            if (debug == true) {
                scene.add(grid[b[0]][b[1]]);
            }
        }


        function makeBlock(str) {

            var block;
            if (str == "full") {

                block = new THREE.Mesh(wireGeometry, wireMaterial);
                block.name = "empty";

                return block;
            }

        }


        function Swap(a, b) {


            var tmp = grid[a[0]][a[1]];
            grid[a[0]][a[1]] = grid[b[0]][b[1]];
            grid[b[0]][b[1]] = tmp;


        }

        function CheckGridName(x, y) {


            return grid[y][x].name;
        }

        function UpdateScore() {
            "use strict";
            score = 0;
            grid.forEach(function (array) {

                array.forEach(function (box) {
                    if (box.name != "empty") {
                        score += parseInt(box.name);
                    }

                });

            });

            if (score > topScore) {

                topScore = score;
            }

            scoreTexture.clear('white');
            scoreTexture.context.font = "18px monospace";
            scoreTexture.drawText("Score:", 28, 28, 'black');
            scoreTexture.drawText(score, 28, 48, 'black');
            scoreTexture.texture.needsUpdate = true;


            topScoreTexture.clear('white');
            topScoreTexture.context.font = "18px monospace";
            topScoreTexture.drawText("Best Score:", 12, 28, 'black');
            topScoreTexture.drawText(topScore, 12, 48, 'black');
            topScoreTexture.texture.needsUpdate = true;


            scoreBox.material.color = ScoreColor(score);
            topScoreBox.material.color = ScoreColor(topScore);


        }


        function ScoreColor(findscore) {

            for (var i = 0; i < 12; i++) {
                if (findscore < Math.pow(2,i)) {
                    return material2048[i].color;
                }

            }

        }
    </script>




    <!--   <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>-->
    <script>
        window.jQuery || document.write('<script src="js/vendor/jquery-1.11.2.min.js"><\/script>')
    </script>
    <script src="js/plugins.js"></script>
    <script src="js/main.js"></script>
</body>

</html>
